{% extends 'base.html' %}

{% block head %}
{{ super() }}
{# Injetar permissões do usuário para o JS #}
<script>
    const USER_PERMISSIONS = {
        isAdmin: {{ current_user.is_admin_user | tojson }},
    isAgente: { { current_user.is_agente | tojson } }
        };
</script>

<!-- Importações de CSS do FullCalendar (exatamente como no seu código antigo que funcionava) -->
<link href="https://cdn.jsdelivr.net/npm/@fullcalendar/core@6.1.11/index.global.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/@fullcalendar/daygrid@6.1.11/index.global.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/@fullcalendar/list@6.1.11/index.global.min.css" rel="stylesheet">
{# Removida importação de timegrid CSS, pois seu código antigo não a usava. #}

{% endblock %}

{% block content %}
<div class="container mt-4">
    <div class="calendar-page-wrapper"> {# NOVO: Wrapper para o efeito glassmorphism #}
        <h1>Calendário de Agendamentos</h1>

        <div style="text-align: center; margin-bottom: 20px;">
            <form action="{{ url_for('agendar') }}">
                <button type="submit" class="btn btn-primary">Fazer Agendamento</button>
            </form>
        </div>

        <div id='calendar'></div>
    </div> {# FIM do calendar-page-wrapper #}
</div>

<!-- O modal customizado de detalhes será removido, pois agora vamos para uma nova página.
     Deixei o HTML por enquanto, mas ele não será mais ativado pelo eventClick. -->
<div id="eventDetailModal" class="modal hidden">
    <div class="modal-content">
        <span class="close-button">×</span>
        <h2>Detalhes do Agendamento</h2>
        <p><strong>Título:</strong> <span id="modalTitle"></span></p>
        <p><strong>Status:</strong> <span id="modalStatus"></span></p>
        <p><strong>Cliente:</strong> <span id="modalClientName"></span></p>
        <p id="clientContactRow"><strong>Contato do cliente:</strong> <span id="modalClientContact"></span></p>
        <p id="clientEmailRow"><strong>E-mail do cliente:</strong> <span id="modalClientEmail"></span></p>
        <p id="agentAssignedRow"><strong>Agente atribuído:</strong> <span id="modalAgentAssigned"></span></p>
        <p><strong>Serviço:</strong> <span id="modalService"></span></p>
        <p><strong>Local:</strong> <span id="modalLocation"></span></p>
        <p><strong>Observações:</strong> <span id="modalObservations"></span></p>
        <p><strong>Data:</strong> <span id="modalDate"></span></p>
        <p><strong>Hora:</strong> <span id="modalTime"></span></p>
    </div>
</div>

{# MOVIDO: TODOS OS SCRIPTS JS DO FULLCALENDAR E SEU CÓDIGO PARA O FINAL DO BODY #}
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/core@6.1.11/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/daygrid@6.1.11/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/list@6.1.11/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/core@6.1.11/locales-all.global.min.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', async function () {
        const calendarEl = document.getElementById('calendar');
        // REMOVIDAS referências a elementos do modal que não serão mais usados no eventClick

        const calendar = new FullCalendar.Calendar(calendarEl, {
            locale: 'pt-br',
            initialView: 'dayGridMonth',
            headerToolbar: {
                left: 'prev,next today',
                center: 'title',
                right: 'dayGridMonth,listMonth'
            },

            events: async function (fetchInfo, successCallback, failureCallback) {
                try {
                    const response = await fetch('/eventos');

                    if (!response.ok) { // Alterado para apenas verificar !response.ok
                        const errorData = await response.json().catch(() => ({ message: 'Erro desconhecido ou resposta não-JSON.' }));
                        console.error('Erro ao buscar eventos:', response.status, response.statusText, errorData);
                        failureCallback({ message: errorData.message || `Erro ao carregar eventos: ${response.status} ${response.statusText}` });
                        alert(`Erro ao carregar eventos: ${errorData.message || response.statusText}. Verifique o console para mais detalhes.`);

                        if ((response.status === 401 || response.status === 403) && errorData.redirect_to) {
                            alert(errorData.message || 'Sua sessão expirou ou você não tem permissão. Redirecionando para login.');
                            window.location.href = errorData.redirect_to;
                        }
                        return;
                    }

                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        const eventsData = await response.json();
                        successCallback(eventsData);
                    } else {
                        const errorText = await response.text();
                        console.error('Resposta de /eventos não é JSON:', errorText);
                        failureCallback({ message: 'Resposta inválida do servidor (não é JSON).' });
                        alert('Erro ao carregar eventos: Resposta inválida do servidor.');
                    }
                } catch (error) {
                    console.error('Erro de rede ou ao processar eventos:', error);
                    failureCallback(error);
                    alert('Erro de rede ou ao processar eventos. Verifique o console.');
                }
            },
            editable: false,
            eventStartEditable: false,
            eventDurationEditable: false,
            selectable: true,
            eventColor: '#3788d8',

            eventDidMount: function (info) {
                const status = info.event.extendedProps.status;
                if (status) {
                    info.el.classList.add(`event-status-${status}`);
                }
            },

            eventContent: function (arg) {
                if (arg.view.type === 'listMonth') {
                    const observacoes = arg.event.extendedProps.observacoes;
                    return {
                        html: `
                            <div class="fc-event-details">
                                <div class="fc-event-title">${arg.event.title}</div>
                                <div class="fc-event-meta">
                                    <span>${arg.event.extendedProps.usuario_nome}</span> |
                                    <span>${arg.event.extendedProps.unidade}</span> |
                                    <span>${arg.event.extendedProps.empreendimento}</span>
                                </div>
                                ${observacoes && observacoes !== 'N/A' ? `<div class="fc-event-notes">Obs: ${observacoes}</div>` : ''}
                            </div>
                        `
                    };
                }
                return { html: arg.event.title };
            },

            // NOVO: Redireciona para a página de detalhes do agendamento
            eventClick: function (info) {
                const eventId = info.event.id;
                window.location.href = `/agendamento/${eventId}`; // Redireciona para a nova rota
            }
        });

        calendar.render();

        // REMOVIDOS listeners de fechar modal, pois o modal não será mais usado no clique de evento
    });
</script>
{% endblock %}